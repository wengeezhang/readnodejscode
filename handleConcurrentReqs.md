解读点：xxx。

[TOC]

# 一.故事
这一天，10010店铺同时来了两位客人，王大妈和李大妈。

俩人前后脚进了店铺，都往“红色篮子”里面写了字条（王大妈的字条在前，李大妈的字条在后）。
![alt 王大妈和李大妈写字条到红色篮子]()
机器人马上过来，从篮子里取出两个字条。

机器人先给王大妈分配了一个“蓝色篮子”，在上面写了一个数字“5”；然后在篮子上方放了一个探测器。
接着机器人又给李大妈分配了一个“蓝色篮子”，在上面写了一个数字“6”；然后也在篮子上方放了一个探测器。
做完这些，机器人就走了。
![alt 王大妈和李大妈的篮子分配完毕，王大妈的在队列前]()

王大妈要买1斤芝麻，于是写了个字条“芝麻，1斤”，放到5号篮子里；李大妈要买2瓶矿泉水，于是写了个字条“矿泉水，2瓶”，放到6号篮子里。

王大妈和李大妈在同一时间完成了写字条，放字条的动作。

此时机器人过来了。

它先从5号篮子里面取出王大妈字条，转身走到后面去取了1斤芝麻，放到了5号篮子里。王大妈拿到了东西，离开店铺。

![alt 机器人取芝麻放到5号篮子]()

接着它又从6号篮子里面取出李大妈的字条，转身走到后面取了2瓶矿泉水，放到6号篮子里。李大妈拿到了东西，离开店铺。
// todo 5号篮子的消失时机
![alt 机器人取矿泉水放到6号篮子，5号篮子已经消失]()
# 二.分析和对照
从上面的故事场景中看到，10010店铺可以同时服务多个客户。这跟nodejs服务可以处理并发请求是一样的。

但是由于店铺中只有一个机器人，所以多个客户的交易，还是按照顺序来完成的。nodejs也是一样，虽然可以处理高并发的海量请求，但是实际上还是按照次序一个一个串行处理完成的。

## 1.原理分析
nodejs服务启动后，只有一个主线程在运行一个无限循环。

在这个循环中，libuv首先通过服务实例的观察者，接受新的客户端tcp握手请求。tcp握手请求建立完成后，对每一个tcp链接创建一个新的客户端实例，并注册到libuv中。
## 2.关联
* 王大妈 --> 用户A访问服务，建立的tcp链接
* 李大妈 --> 用户B访问服务，建立的tcp链接
* 5号篮子  --> libuv封装的客户端实例1,用来和用户A通信
* 6号篮子  --> libuv封装的客户端实例2,用来和用户B通信
* 机器人   --> nodejs主线程
# 三. nodejs源码解读
## 1. 解读入口


## 2. 源码解读


# 四.总结：
